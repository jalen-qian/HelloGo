package main

import (
	"fmt"
)

func printIntSlice(s []int, name string) {
	fmt.Printf("len(%s)=%d, cap(%s)=%d,%s=%v,地址：%p\n", name, len(s), name, cap(s), name, s, s)
}

/**
从切片中删除元素：
Go语言中没有直接提供从切片删除元素的函数，不过可以通过切片本身的性质来实现
*/
func main() {

	s1 := []int{1, 2, 3, 4, 5}
	printIntSlice(s1, "s1") //len(s1)=5, cap(s1)=5,s1=[1 2 3 4 5],地址：0xc00007a060
	//删除s1中索引位置为2的元素，方法如下
	s1 = append(s1[:2], s1[3:]...)
	//发现删除后的切片底层地址并没有改变，但是切片变成了[1 2 4 5]
	//思考：底层数组变成了什么？
	printIntSlice(s1, "s1") //len(s1)=4, cap(s1)=5,s1=[1 2 4 5],地址：0xc00007a060

	//为了研究这个问题，通过一个数组切片操作来构造一个切片
	a1 := [...]int{1, 2, 3, 4, 5}
	s2 := a1[:]
	printIntSlice(s2, "s2") //len(s2)=5, cap(s2)=5,s2=[1 2 3 4 5],地址：0xc00007a090
	//这一步，将s2的第2号元素3删除掉了
	s2 = append(s2[:2], s2[3:]...)
	//再次打印s2
	printIntSlice(s2, "s2") //len(s2)=4, cap(s2)=5,s2=[1 2 4 5],地址：0xc00007a090
	//同时打印底层数组a1
	fmt.Println(a1) //[1 2 4 5 5]

	//底层数组为什么变成了[1 2 4 5 5] ?
	//首先看append的第一个参数，s2[:2]，这是一个新切片，通过对s2进行一次切片操作得到，可以看出这个新切片内存地址和s2是一样的（这个是切片操作的特性，切片操作不改变底层数组）
	printIntSlice(s2[:2], "s2[:2]") //len(s2[:2])=2, cap(s2[:2])=5,s2[:2]=[1 2],地址：0xc00007a090

	//解释：
	//1.切片是对数组的封装，切片本身不存储数据，通过底层数组存储数据
	//2.在执行append操作时，是将s2[3:]包含的元素（4和5）添加到s2[:2]这个切片的后面，s2[:2]这个切片的值是[1 2],长度是2，容量是5
	//实际上这个s2[:2]的底层数组和s2是同一个，都是a1
	//3.在执行append操作过程中，实际上是将4和5这两个int数值添加到了s2[:2]的切片的后面，也就是底层数组的第2和3的位置，所以最终底层数组变成了[1 2 4 5 5]
}
