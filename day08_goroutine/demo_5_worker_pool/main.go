package main

import "fmt"

/**
当任务比较多时，我们需要开启多个协程(goroutine)去处理任务，但是如果每个任务都开启一个协程，那么就会导致
协程暴涨或者泄露。

为了解决这个问题，我们可以采用任务池（协程池）的思想，分配有限个协程同时工作，当某个协程处理完了任务，就接着
处理下一个，直到所有任务都处理完，这样能保证最多执行任务的协程个数是确定的。

下面是一个协程池的例子:
*/

/**
协程池（工人）的任务：取出一个数，将这个数计算平方，并生成 " x^2=y"格式的字符串，保存到另一个通道
规定：协程池中最多有3个协程在工作，但是任务数有5个（必须有1到2个协程多处理工作）
*/

func worker(i int, jobs <-chan int, results chan<- string) {
	//工人不断的从任务通道中取任务，直到任务通道中没有任务
	for job := range jobs {
		fmt.Printf("我是工人%d 开始处理任务%d\n", i, job)
		res := fmt.Sprintf("%d^2=%d\n", job, job*job)
		//处理完任务，将结果数据发送到结果通道中
		results <- res
		fmt.Printf("我是工人%d 处理任务%d结束\n", i, job)
	}
}

func main() {
	//创建任务通道
	jobs := make(chan int, 5)
	//创建结果通道
	results := make(chan string, 5)

	//开启3个协程，处理任务
	for i := 0; i < 3; i++ {
		go worker(i+1, jobs, results)
	}

	//发起5个任务
	for j := 0; j < 5; j++ {
		jobs <- j + 1
	}
	//发起完任务，就关闭通道
	close(jobs)

	//由于results通道数据是在协程池中发送的，不知道是哪个协程发送最后一个任务，所以没有办法手动close
	//这里不能用for range循环来遍历results，没有close的通道for range会无限循环（死锁）
	//故而这里手动循环5次（因为已经知道有5个任务，所以通道中的数据肯定有5个）
	for r := 0; r < 5; r++ {
		fmt.Println(<-results)
	}

	/**
	程序最终运行结果：
	可以发现，工人1处理了1个任务，工人2和3都处理了2个任务，总共发起3个协程处理了5个任务，这样比发起5个协程效率要高

	我是工人3 开始处理任务1
	我是工人3 处理任务1结束
	我是工人3 开始处理任务4
	我是工人2 开始处理任务3
	我是工人2 处理任务3结束
	我是工人1 开始处理任务2
	我是工人1 处理任务2结束
	我是工人3 处理任务4结束
	1^2=1

	4^2=16

	3^2=9

	2^2=4

	我是工人2 开始处理任务5
	我是工人2 处理任务5结束
	5^2=25
	*/
}
